# 미션

## **✅** 오늘 한 일

- **리서치**
    - HTTP 리다이렉트
    - URLDecoder
    - 유틸리티 클래스
    - static 키워드
- **구현**
    - http://localhost:8080/register.html에 대한 요청을 [http://localhost:8080/registration](http://localhost:8080/register.html)으로 리다이렉트
    - 폼에 입력된 내용이 GET 요청으로 전달되도록 구현
    - GET 요청을 받아, 파싱하여 User를 생성하고 Database에 저장
        - 문자열 파싱을 통해 확장자 추출
    - 리팩토링 (클래스들의 역할을 분리)
        - 쿼리 스트링 파싱, HttpRequest 객체 생성, 라우팅 기능 분리
    - 테스트 코드 작성
- **스쿼드 세션**
    - 다른 그룹의 멤버들과 코드 공유 및 리뷰

<br>

## **💡** 느낀 점

### 1. 유틸리티 클래스의 사용

`HttpRequestRouter`를 유틸리티 클래스로 만들어도 괜찮을까 의문이 들었다. 유틸리티 클래스로 만드는 것이 적합한 케이스와 부적합한 케이스에 대해 알아보고 싶어졌다.

**유틸리티 클래스란?**

- 공통 기능을 담아두는 클래스
- 상태를 가지지 않음 → 인스턴스 변수 없음
- 메서드만 static으로 제공 → 객체 생성 없이 사용
- 다양한 곳에서 재사용 가능
- 객체지향적인 관점에서는 좋지 않음
    - 다른 클래스와의 종속성이 커지고, 테스트가 어려워짐

**적합한 케이스**

- 상태가 존재하지 않는 순수 기능들의 모음
- 여러 클래스에서 공통적으로 사용하는 기능
- 핵심로직 외의 보조적인 기능
- 객체 간 협력 없이 독립적으로 동작하는 경우

**부적합한 케이스**

- 상태를 가질 수 있는 경우
- 비즈니스 로직의 책임이 있는 경우
- 다형성/확장이 필요한 경우
- 의존성 주입이 필요한 경우
- 테스트가 필요한 경우

`HttpRequestRouter`는 상태를 가지지는 않지만 요청에 대한 처리 경로를 판단하는 비즈니스 로직을 수행하고 있으며, 추후의 확장 가능성까지 고려했을 때, 유틸리티 클래스로는 부적합하다고 판단하였다.

### 2. static 사용

`RequestHandler`가 필드로 가지고 있는 `HttpRequestParser`와 `HttpResponseSender`를 static으로 선언했었다. static으로 선언할 필요가 있었는지 문득 의문이 들었다.

**static을 사용할 때의 장단점**

**장점**

- 객체를 한 번만 생성하므로 메모리 사용 측면에서 효율적
    - 모든 `RequestHandler` 인스턴스가 공통 인스턴스를 공유하게 됨
    - ex) 상태가 없는 유틸리티 클래스라면 매번 생성할 필요 없음

**단점**

- 테스트가 어렵고 확장성과 유연성이 떨어짐
    - 의존성을 주입하기 어렵고 모킹도 불편해짐
- 공유 자원이기 때문에, 내부 상태가 없는 경우만 안전
    - 상태를 갖게 될 경우, Thread-Safety 이슈가 생길 수 있음

현재는 `HttpRequestParser`와 `HttpResponseSender` 모두 상태를 가지지 않기 때문에 기능적으로는 static을 사용해도 문제가 없지만, 유연성과 의존 분리, 테스트 용이성을 고려하여 static을 사용하지 않는 것이 낫겠다고 생각했다. 키워드 하나하나도 근거를 가지고 사용할 수 있도록 해야겠다.

<br>

## **🎯** 앞으로 할 일

- 궁금했던 점
    - `final` 키워드에 대한 조사
        - final 키워드에 대한 이해가 부족하다고 느껴졌다.
        - 주간 피드백 수업에서도 관련 내용이 나왔으니, 연계하여 조사해보고 싶다.
    - Builder 패턴
        - 세션을 진행해보니 `HttpRequest`, `HttpResponse` 객체 생성 시에 Builder 패턴을 적용한 분들이 눈에 띄었다.
        - Builder 패턴을 통해 개선할 수 있는 부분이 있을지 알아보자.
    - 오브젝트 책 알아보기
        - 스쿼드 세션을 같이 진행하던 분이 내용이 좋다고 추천해주셨다.
- 구현
    - 리팩토링
        - 라우팅 관련 기능을 조금 더 효율적으로 재구성해보고 싶다.
    - keep-alive 적용해보기

<br><br><br>

# 주간 피드백 수업

## **✅** 오늘 한 일

- **수업 내용**
    - 커밋 관련 피드백
        - 커밋 메세지 작성 요령 → 진행 흐름이 잘 드러나도록
        - 커밋 단위를 조금 더 잘게 쪼갤 필요 있음
    - 로그 출력 관련
        - System.out.printf() 사용하지 않도록 주의
        - 로그 출력 시에는 무슨 의미인지 분명하게, 약속된 Delimeter 사용, 되도록이면 JSON 포맷 활용
    - HTTP Request 관련 처리
        - Header에 공백이 포함되어 있을 수 있음 → OWS
        - 대소문자를 구분하지 않고 인식할 수 있어야 함
        - Request Line 파싱 시에도 여러 개의 연속된 공백이 등장할 수 있음
    - 반복적으로 사용되는 문자열을 constant이나 enum으로 추출하는 것을 권장
    - String 관련 개념들
        - String Constant Pool
        - Effectively Final
    - 적절한 ThreadPool의 크기
        - CPU 코어 수 + 1

<br>

## **💡** 느낀 점

### 1. 커밋 관리에 조금 더 신경을 쓰자

미션 내용에만 집중하다가, 커밋 메세지 작성이나 커밋 단위에는 신경을 비교적 쓰지 못한 것 같다. PR 관련 실수도 한 번 있었다. 주간 피드백 수업에서 나온 내용을 바탕으로 다음 미션부터는 커밋 과정에 공을 들이고 싶다.

다른 사람이 커밋 내역만 보더라도 개발 과정을 어느 정도 이해할 수 있도록 해봐야겠다.

### 2. String에 대해 더 자세히 알아보자

주간 피드백 수업에서 String의 특성에 대한 내용이 나왔는데, 잘 모르던 내용이었다. 굉장히 기초적인 데이터타입임에도 불구하고 모르는 부분이 많다는 점에서 충격을 받았다.

String Constant Pool, Effectively Final 등 수업 시간에 다뤘던 키워드 위주로 조금 더 깊게 조사해보고 정리해야겠다.

<br>

## **🎯** 앞으로 할 일

- 궁금했던 점
    - 로그 사용 방법에 대한 조사
        - 기본적인 출력 방법은 알고 있지만, 출력된 로그 내용을 본격적으로 활용한 경험은 부족한 것 같다.
        - 종합프로젝트를 대비해서, 로그 사용법을 미리 공부해두자.
    - String 관련 개념
        - String Constant Pool, Effectively Final 등 수업 시간에 다뤘던 키워드 위주로 정리해보자.
- 미션 관련 피드백
    - HTTP Request를 읽어들일 때, 다양한 케이스에 대한 처리
        - 공백, 대소문자 문제 등
