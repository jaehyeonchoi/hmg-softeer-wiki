# 미션


## **✅** 오늘 한 일

- **리서치**
    - Java 버전별 Thread 모델의 변화 과정
    - ThreadPool 종류별 특성 비교 정리
- **구현**
    - 예외 상황 (404, 405 등) 처리 로직 추가
    - 리팩토링
        - HTTP Request,Response 관련 역할을 클래스로 분리
        - 상수 및 enum 도입
    - 요청받은 정적 파일의 확장자에 따라, 적절한 ContentType을 Header에 담아 Response 보내기
- **그룹 세션**
    - 그룹 멤버들과 코드 공유 및 리뷰

<br>

## **💡** 느낀 점

### 1. HttpRequest / HttpResponse 관련 역할을 클래스로 분리

HttpResponse를 보낼 때, Socket이 닫힌 상태라서 보낼 수 없는 현상이 있었다.

**원인 :** 

- HttpRequest를 읽을 때, `try-with-resource`를 통해 InputStream과 BufferedReader 자원을 정리
    - InputStream을 닫으면 Socket 자체도 함께 닫힌다는 것을 알지 못했음
    - HttpResponse를 보내는 시점에는, Socket이 이미 닫힌 상태이므로 응답 불가능

**해결 방법 :**

- InputStream, OutputStream 등의 내부 스트림을 따로 정리할 필요가 없었음
    - Socket 자원만 제대로 관리하면 내부 스트림까지 알아서 정리 가능
    - Socket에만 `try-with-resource`를 적용하여 메모리 누수 관리하도록 수정하여 해결

→ 개념을 제대로 이해하지 못하고, 무작정 자원 정리에만 집중했던 것이 문제였다.

→ 어떤 프로세스로, 어떻게 동작하는지 사전에 제대로 이해하고 사용하는 것이 좋겠다.

### 2. MIME 타입을 어떤 방식으로 처리할지

크게 두 가지 방식이 있었는데, 각각의 장단점이 달라 어떤 방식으로 구현할지 고민되었다.

**1. 파일 확장자를 기반으로 수동 매핑하기**

- 조건문이나, Map을 통해 직접 관리
- 직접 추가한 확장자만 관리 가능
    - 결과가 예측 가능하므로 안정적
    - 필요한 파일 확장자를 누락할 가능성 있음
    - 유지보수 측면에서 불리
- OS 등의 실행환경의 영향 적음

**2. `Files.probeContentType()` 활용하기**

- 메서드를 통해 간단하게 사용 가능
    - 다양한 확장자를 자동으로 인식
    - 직접 파일 확장자를 등록할 필요 없음
- OS 등 실행환경의 영향에 따라 다른 동작을 할 수도 있음

→ 미션의 규모가 작고, 매핑을 직접 구현해보는 것이 도움이 될 것이라고 판단하여, 수동 매핑으로 구현했다.

### 3. 어떤 ThreadPool을 사용하는 것이 좋을까

그룹세션 시간에 코드를 공유해보니, 각자 사용한 ThreadPool이 달라 흥미로웠다. 크게 두 가지 방식이 나왔다.

1. `newFixedThreadPool`
2. `newCachedThreadPool`

각 방식에 어떤 차이가 있을지 알아봤다.

| 항목 | `newFixedThreadPool(int nThreads)` | `newCachedThreadPool()` |
| --- | --- | --- |
| **스레드 개수** | 고정된 개수 (`nThreads`) | 필요할 때 무제한 생성 |
| **큐 타입** | 무제한 대기 큐 (`LinkedBlockingQueue`) | 큐 없이 바로 새 스레드 생성 |
| **사용 예시** | 일정한 수의 작업을 동시에 처리할 때 | 많은 짧은 작업을 빠르게 처리할 때 |
| **장점** | - 리소스 제어 용이- 예측 가능한 성능 | - idle 스레드 재사용- 대기 없이 빠른 처리 |
| **단점** | - 큐가 너무 쌓이면 OOM 위험- 작업이 밀릴 수 있음 | - 과도한 스레드 생성 위험- CPU/메모리 과부하 가능 |
| **스레드 재사용** | 가능 (idle 상태 유지) | 매우 활발하게 재사용 |
| **타임아웃** | 없음 (스레드 계속 유지) | 60초 이상 idle 시 제거 |

요약하자면,

`newFixedThreadPool` : 요청의 수가 예측 가능하고, 장시간 수행되는 작업이 일정할 때 적합

`newCachedThreadPool` : 많은 양의 짧은 작업이 갑자기 몰릴 수 있을 때 적합

→ 이번 미션에서는 ThreadPool의 종류가 크게 중요하게 작용하지는 않았지만,
미리 특성들을 파악에 두면, 실전에 적용할 때 큰 도움이 될 것 같다.

<br>

## **🎯** 앞으로 할 일

- 궁금했던 점
    - Record Class
        - 그룹멤버 중에서 요청, 응답 객체를 Record Class로 구현한 분이 계셨다.
        - 특징, 사용법을 조금 더 알아보기
    - Keep-Alive Timeout
        - Keep-Alive의 Timeout 설정 방법과 작동 방식이 궁금해졌다.
        - ex) 첫 타임아웃 그대로? 새로운 통신 있을 때마다 갱신?
- 구현
    - GET을 통해 회원가입 기능 구현
    - 테스트 코드 작성

<br><br><br>

# 종합프로젝트


## **✅** 오늘 한 일

- 팀 회의
    - 주제 및 배경 구체화
- 기술적으로 도전해 볼 수 있는 기능 찾아보기
- 사용할 수 있는 기술 리서치

<br>

## **💡** 느낀 점

### 1. 도메인에 대한 조사의 중요성

- 기획/디자인 팀원분들께서 굉장히 구체적으로 배경 조사를 해주셨다.
    - ex) 필드 리서치, 업체 인터뷰, 경쟁사 분석 등…
- 도메인에 대한 이해도가 쌓이자, 나아가야 할 방향성이 선명해지는 것을 실감할 수 있었다.

### 2. 프로젝트에 꼭 필요한 기술을 사용하자

- 단순히 좋아보이는 기술보다는, 정말 필요한 기술을 사용하는 것이 좋을 것 같다.
- 해당 기술을 왜 사용했는지, 그 이유와 근거를 명확하게 제시할 수 있어야겠다.

<br>

## **🎯** 앞으로 할 일

- 활용 가능한 기술에 대해 조금 더 자세히 조사해보기
    - 쿼리 최적화 : 복잡한 데이터 조회 시 효율을 높이기 위해, QueryDSL 사용 고려
    - 서버 모니터링 : 관련 툴들에 대한 공부 필요
    - 보안 : 보안 측면에서 신경써야 할 부분, 활용할 수 있는 기술 고려
