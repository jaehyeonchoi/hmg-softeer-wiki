# 미션


## **✅** 오늘 한 일

- **리서치**
    - Java 버전별 Thread 모델의 변화 과정
    - ThreadPool 종류별 특성 비교 정리
- **구현**
    - 예외 상황 (404, 405 등) 처리 로직 추가
    - 리팩토링
        - HTTP Request,Response 관련 역할을 클래스로 분리
        - 상수 및 enum 도입
    - 요청받은 정적 파일의 확장자에 따라, 적절한 ContentType을 Header에 담아 Response 보내기
- **그룹 세션**
    - 그룹 멤버들과 코드 공유 및 리뷰

<br>

## **💡** 느낀 점

### 1. HttpRequest / HttpResponse 관련 역할을 클래스로 분리

HttpResponse를 보낼 때, Socket이 닫힌 상태라서 보낼 수 없는 현상이 있었다.

**원인 :** 

- HttpRequest를 읽을 때, `try-with-resource`를 통해 InputStream과 BufferedReader 자원을 정리
    - InputStream을 닫으면 Socket 자체도 함께 닫힌다는 것을 알지 못했음
    - HttpResponse를 보내는 시점에는, Socket이 이미 닫힌 상태이므로 응답 불가능

**해결 방법 :**

- InputStream, OutputStream 등의 내부 스트림을 따로 정리할 필요가 없었음
    - Socket 자원만 제대로 관리하면 내부 스트림까지 알아서 정리 가능
    - Socket에만 `try-with-resource`를 적용하여 메모리 누수 관리하도록 수정하여 해결

→ 개념을 제대로 이해하지 못하고, 무작정 자원 정리에만 집중했던 것이 문제였다.

→ 어떤 프로세스로, 어떻게 동작하는지 사전에 제대로 이해하고 사용하는 것이 좋겠다.

### 2. MIME 타입을 어떤 방식으로 처리할지

크게 두 가지 방식이 있었는데, 각각의 장단점이 달라 어떤 방식으로 구현할지 고민되었다.

**1. 파일 확장자를 기반으로 수동 매핑하기**

- 조건문이나, Map을 통해 직접 관리
- 직접 추가한 확장자만 관리 가능
    - 결과가 예측 가능하므로 안정적
    - 필요한 파일 확장자를 누락할 가능성 있음
    - 유지보수 측면에서 불리
- OS 등의 실행환경의 영향 적음

**2. `Files.probeContentType()` 활용하기**

- 메서드를 통해 간단하게 사용 가능
    - 다양한 확장자를 자동으로 인식
    - 직접 파일 확장자를 등록할 필요 없음
- OS 등 실행환경의 영향에 따라 다른 동작을 할 수도 있음

→ 미션의 규모가 작고, 매핑을 직접 구현해보는 것이 도움이 될 것이라고 판단하여, 수동 매핑으로 구현했다.

### 3. 어떤 ThreadPool을 사용하는 것이 좋을까

그룹세션 시간에 코드를 공유해보니, 각자 사용한 ThreadPool이 달라 흥미로웠다.

1. newFixedThreadPool
2. newCachedThreadPool

<br>

## **🎯** 앞으로 할 일

- 궁금했던 점
    - record class
        - 데이터를 담아두는 용도로만 사용할 때 활용 가능?
    - keep-alive timeout
        - 첫 타임아웃 그대로? 새로운 통신 있을 때마다 갱신?
- 구현
    - GET을 통해 회원가입 기능 구현
    - 테스트 코드 작성

<br>

# 종합프로젝트


## **✅** 오늘 한 일

- 팀 회의
    - 주제 및 배경 구체화
- 기술적으로 도전해 볼 수 있는 기능 찾아보기
- 사용할 수 있는 기술 리서치

<br>

## **💡** 느낀 점

- 도메인에 대한 조사가 구체적으로 이뤄지고 나니 방향성이 명확하게 잡히고 있다.

<br>

## **🎯** 앞으로 할 일

- 활용 가능한 기술에 대해 조금 더 자세히 조사해보기
    - 쿼리 최적화 → queryDSL
    - 서버 모니터링
    - spring security
