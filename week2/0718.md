# 1. 리뷰

## 오늘 한 작업

### 웹 서버 5단계 미션

- PR merge 병합 문제 해결
- Header명 대소문자 구분 로직 수정
- 쿼리스트링/Form 파싱 로직 수정
- README.md 작성

### 스쿼드 세션

- 다른 그룹 사람들과 함께 일주일 동안의 작업 내용 공유하기
    - 정적 리소스 처리 방식 논의
    - 라우팅 방식 논의

### 수업

- 주간 피드백
    - 상대방을 배려하는 코드 리뷰
- Database에 Hashmap 쓰지 말기 → ConcurrentHashMap
- 공용어를 사용하기
- valid, empty, exist의 차이
- 보장되지 않는 입력 예외에 주의
    - Header에 Content-Length가 온다는 보장 없음
    - ‘=’로 split해도 안전하다는 보장 없음
- Map.getOrDefault()
    - 키가 존재하면 해당 키에 매핑된 값, 아니면 기본 값을 반환
    - 장점
        - nullPointException 예방
            - 기본값이 null이 나온다면? → 기본값은 최대한 직관적이고 단순해야 함
        - 가독성 좋음
    - 단점
        - 타입 안정성 : 기본값 설정이 잘못된 경우

<br>

## 작업 과정에서 배운 것

### 1. 특성을 파악하고 개념 사용하기

Header 명에서 대소문자를 구분하지 않고도 사용 가능하도록 수정해야했다.

가장 먼저 떠오르는 방식은 입력받은 헤더명을 모두 소문자로 변환하고 통일해서 사용하는 것이었다. 

그러다가 `TreeMap<>(String.CASE_INSENSITIVE_ORDER)` 라는 방식을 찾았다. 헤더 정보를 헤더명을 키로 해서 Map 형태로 저장했는데, 해당 방식을 사용하면 키 검색 시에 대소문자를 구분하지 않는다고 했다. 처음 보는 방식이라 한 번 사용해봤다.

이후에 Dangle님의 코드 리뷰를 받으면서, 왜 이런 방식을 사용했냐는 질문을 받았다. 그제서야 두 방식의 차이에 대해서는 크게 생각해보지 않았었다는 것이 떠올랐다. 알아보니 TreeMap에서는 데이터를 Tree 형태로 정렬해서 저장하기 때문에, 검색 속도가 떨어지고 등록된 순서가 보장되지 않는다는 단점이 있었다. 새로운 방식을 사용해보는 것도 좋지만, 어떤 특성과 장단점을 가지고 있는지를 알아보지 않은 것은 문제라고 생각했다.

스쿼드 세션 시간에 세션ID 생성 방식에 대한 주제가 나왔다. 유진님께서 UUID를 사용하면서, 다른 방식들과의 비교를 정리해둔 것을 공유해주셨다. 기술의 특성과 장단점을 명확하게 이해하면서 사용하는 부분이 정말 본받을 점이라고 느껴졌다.

<br>

### 2. 당연히 정상적인 입력이 올 것이라고 생각하지 말자

쿼리스트링이나 폼 데이터를 파싱할 때, 단순히 = 기준으로 파싱한 다음, 배열의 첫 두 개의 원소를 가져와서 각각 Key와 Value로 사용했다. 하지만 이렇게 하면 “aaa=bbb=ccc”와 같은 문자열을 파싱하면 배열의 원소가 3개가 되고, “=ccc” 부분은 소실될 수 있다. 이를 해결하기 위해, 첫 번째 =에서만 문자열을 분리하도록 코드를 수정했다. 

이와 같은 예시말고도 전반적으로 입력에 대해서 안일하게 예외 처리하고 있는 부분이 많이 있다. 다양한 예외 상황을 떠올려보고 사전에 문제를 막을 수 있도록 코드를 개선해봐야겠다.

<br>

## 어려웠던 점

### **1. HttpResponseBuilder를 유연성있게 개선**

지난 번에 HttpResponseBuilder에 Builder 패턴을 적용했었다.

Builder 패턴을 적용하면서 객체의 필드 조합이 용이해지고 유연성이 높아졌지만, 메서드 체인을 통해 HttpResponse 객체를 생성하다보니 코드가 지나치게 장황해지는 경향이 있었다.

그래서 redirect()나 methodNotAllowed() 등, 자주 쓰이는 형태의 응답을 만드는 Builder 코드를 메서드로 정의하여 사용하고 있었다.

하지만 redirect()에도 헤더에 쿠키를 정보를 넘겨줘야 하는 등, 자주 쓰이는 응답들도 항상 같은 형태로만 사용되는 것은 아니었다.

이를 개선해보고자, redirect() 등의 메서드의 리턴타입을 HttpResponse가 아닌 HttpResponseBuilder로 변경했다. 해당 메서드들도 메서드 체이닝 형태로 사용하여 헤더를 추가로 지정할 수 있게 했다.

다른 사람의 예시들을 참고하면서 더 깔끔한 방식이 있을지 고민해봐야겠다.

<br>

### 2. 정적 리소스 응답에 대한 책임 분리

이전에 라우팅 구조를 리팩토링하면서, 경로에 따라 리졸버를 매핑해주고 ,매핑되는 리졸버가 없는 경로에 대해서 디폴트 리졸버에서 연관된 정적 리소스를 찾아 응답하도록 했다.

하지만 경로가 매핑된 경우에도 정적 리소스로 응답을 해줘야 하는 케이스가 생겼고, 정적 리소스 응답 로직이 여러 리졸버에 동시에 존재하게 되는 문제가 있었다. 유지보수 측면에서 좋지 않다고 생각하여, 다시 정적 리소스 응답을 전담하는 역할의 필요성에 대해 고민하게 되었다.

지금의 클래스 계층 구조 자체에 어쩔 수 없는 한계가 있어보이기도 해서, 새로운 구조를 고안해봐야겠다고 생각했다.

<br>

# 2. 회고

## Keep

### **1. 함께 하는 사람들과 가까워지기**

- 종합프로젝트 팀원들과 약속을 해서 함께 점심을 먹었다. 식사하고 이동하는 시간 동안 프로젝트와 관련 없는 사소한 이야기들을 많이 나눌 수 있어서 좋았다.
- 단순하게 할 일을 잘 해내는 것도 중요하지만, 같이 공부하고 작업하는 사람들과의 관계 맺기 역시 그에 못지않게 중요하다는 것을 다시 한 번 느꼈다.
- 서로의 일상이나 취향을 공유하면서 인간적으로 가까워질 수 있었다. 심리적으로 안정감도 가져다주고, 모르는 것을 질문하거나, 고민을 털어놓기도 훨씬 쉬워졌다.
- 무엇보다 협업 자체를 즐길 수 있는 환경이 만들어지는 느낌이라, 앞으로도 꾸준히 이런 시간을 가져야겠다는 생각을 했다.

### 2. 실수에서 배우기

- 어제 겪었던 PR 충돌 문제와 비슷한 상황이 오늘 다시 발생했다.
- 어제는 `feature-2`에서 `feature-3`를 파생시킨 뒤, `feature-2`의 README.md를 수정하면서 `feature-3` PR 시 충돌이 발생했다.
- `feature-3`에 `feature-2`를 merge한 뒤 새롭게 PR을 생성하여 문제를 해결할 수 있었다.
- 오늘은 다시 `feature-4`의 PR을 merge할 때 충돌이 발생했는데, 위에 말한 작업을 수행하기 전에 이미 `feature-3`에서 `feature-4`를 생성했기 때문에 `feature-4`에는 해당 내용이 반영되지 않았기 때문이다.
- 어제 이미 한 번 해결해본 문제이기 때문에 능숙하게 문제를 해결할 수 있었다.
- 나아가 비슷한 문제가 연쇄적으로 발생하지 않도록 `feature-5`에는 미리 merge 작업을 해둠으로써 동일한 문제가 다시 발생하지 않도록 했다.

<br>

## Problem

### **1. 새로운 방식을 알게 되는데 한계가 있다**

- 코드 리뷰, 그룹 세션, 스쿼드 세션 등을 통해 다른 사람들의 구현 방식을 들어보고 나의 고민을 공유하고 있다.
- 하지만 이러한 기회들은 참여 인원과 시간에 제약이 있어, 내가 접할 수 있는 방식의 양에도 한계가 있다. 얻게 되는 지식이 편향되는 경향이 있다.

### **2. 아이디어를 떠올리는 데에 너무 많은 시간을 쓰고 있다**

- 문서 작업을 하면서 무슨 내용을 작성할지 고민하는 시간이 길어질 때가 있다.
- 코딩을 할 때도 어떤 식으로 개선할 수 있을지 방향성을 잡느라 늘어질 때가 있다.
- 고민하는 시간을 갖는 게 나쁜 건 아니지만, 무작정 붙잡고만 있는다고 문제가 해결되는 것도 아니다.
- 결국 아무런 소득 없이 시간만 흐르고 생산성이 떨어지게 된다.

<br>

## Try

### **1.** 다른 사람의 PR을 참고해보자

- 그룹 세션이나 스쿼드 세션을 진행하면서 다른 사람의 PR을 참고하고 있는 사람들이 꽤 많다는 것을 알 수 있었다.
- 사실 모두 공개되어 있는 내용이고, 그대로 베끼는 것이 아니라 의도를 파악하고 내 프로젝트에 맞게 적용해보는 건 오히려 적극적인 학습 방법일 수 있다.
- 막히는 부분이 있을 때는 주변의 좋은 예시를 보고, 필요하면 직접 물어보거나 의견을 나눠보자.

### **2. 막힐 때는 다른 일부터 해보자**

- 충분히 생각했는데도 뚜렷한 결과가 나오지 않는 경우에는 다른 일을 먼저 해보자
- 의외로 다른 일을 하다 보면 무의식 중에 아이디어가 떠오르거나, 머리가 식어서 새로운 시야가 트이는 경우도 많다.
- 한 가지 문제에 너무 오래 얽매이지 말고, 당장 해결할 수 있는 문제들부터 빠르게 해치워보자.

<br>

# 3. 학습내용

## 쿠키(Cookie)

- 클라이언트(브라우저)에 저장되는 작은 데이터 조각
- HTTP의 Stateless(무상태) 특성을 보완하여 사용자 상태를 유지하는 데 사용됨

### 주요 용도

- 로그인 세션 유지
- 사용자 환경 설정 저장 (예: 다크 모드, 언어 설정)
- 장바구니 정보 보존
- 사용자 추적 및 통계 수집

### 쿠키 구조

**서버 → 클라이언트 (Set-Cookie)**

- ex) Set-Cookie: sid=abc123; Path=/; Max-Age=3600; HttpOnly

| 항목 | 설명 |
| --- | --- |
| `sid=abc123` | 쿠키의 key와 value |
| `Path=/` | 이 경로 이하의 요청에서만 쿠키 전송 |
| `Max-Age=3600` | 쿠키 유효 시간 (초 단위) |
| `HttpOnly` | 자바스크립트 접근 제한 (보안 강화, XSS 방지) |

**클라이언트 → 서버 (Cookie)**

- ex) Cookie: sid=abc123; theme=dark
    - 여러 개의 쿠키는 `;`로 구분되어 하나의 `Cookie` 헤더에 담김
    - 브라우저는 같은 도메인의 요청에 대해 자동으로 쿠키를 포함시킴

### 쿠키 vs 세션

| 항목 | 쿠키 (Cookie) | 세션 (Session) |
| --- | --- | --- |
| 저장 위치 | 클라이언트 (브라우저) | 서버 |
| 수명 | 직접 지정 (`Max-Age`, `Expires`) | 서버 설정에 따름 |
| 보안 | 노출 가능성 있음 | 상대적으로 안전 |
| 용량 제한 | 작음 (도메인당 약 4KB) | 비교적 큼, 객체 저장 가능 |
| 전송 방식 | 모든 요청에 자동 포함 | 세션 ID만 쿠키에 담아 전송 |
| 사용 예시 | 로그인 정보, 테마, 장바구니 | 로그인 상태, 사용자 인증정보 등 |

### 보안 관련 속성

| 속성 | 설명 |
| --- | --- |
| `Secure` | HTTPS 통신에서만 쿠키 전송 |
| `HttpOnly` | JS에서 접근 불가 (XSS 방지) |
| `SameSite` | 크로스 사이트 요청에서 쿠키 전송 여부 (`Strict`, `Lax`, `None`) 설정 |

### 쿠키 삭제 방법

- **같은 이름, 같은 경로**로 `Max-Age=0` 또는 `Expires`를 과거 시점으로 설정
    - ex) Set-Cookie: sid=abc123; Path=/; Max-Age=0;

<br>

## 싱글톤 객체 필드 vs. static 필드

### 싱글톤 패턴과 static 필드의 공통점

- 둘 다 공유 인스턴스를 제공하는 방식
    - 여러 클래스나 코드에서 동일한 객체를 참조하고 싶은 경우 사용
    - 상태를 공유하고 싶거나, 인스턴스를 한 번만 만들고 계속 재사용하고 싶을 때 사용

### static 필드로 선언하는 경우

```java
public class A {
    private static final Logger logger = new Logger();
}
```

- 해당 클래스(`A`)의 모든 인스턴스가 동일한 `logger` 객체를 공유한다.
- 클래스가 로딩되는 시점에 초기화되며, 이후 변하지 않는다.
- 간단하고 빠르지만, 객체 간의 상태 격리를 할 수 없다.
- 테스트나 확장 측면에서 유연성이 떨어진다.

### 싱글톤 객체를 일반 인스턴스 필드로 주입하는 경우

```java
public class A {
    private final Logger logger;

    public A(Logger logger) {
        this.logger = logger;
    }
}
```

- 외부에서 싱글톤 객체를 주입(DI) 받아 사용
- 여전히 동일한 객체를 참조하지만, 코드 내에서는 `static`을 직접 사용하지 않음
- 테스트 시 mock 객체로 교체 가능하고, 유닛 테스트에 유리
- 의존성을 명확히 드러내므로 코드의 가독성과 확장성이 높아짐

### 주요 차이점

| 항목 | static 필드 | 싱글톤 객체 주입 (인스턴스 필드) |
| --- | --- | --- |
| 객체 생명주기 | 클래스 로딩 시 생성됨 | 컨테이너 또는 외부에서 관리 |
| 유연성 | 낮음 (고정된 인스턴스) | 높음 (테스트 및 교체 가능) |
| 테스트 용이성 | 낮음 | 높음 |
| DI 사용 가능 여부 | 불가능 | 가능 |
| 결합도 | 높음 | 낮음 |
- 단순한 유틸성 클래스나 상태를 가지지 않는 객체의 경우 `static` 필드로 관리해도 문제 없음
- 반면, 상태가 있거나 테스트/확장성 등을 고려해야 하는 경우라면 싱글톤 객체를 외부에서 주입받아 사용하는 것을 권장

<br>

# 4. 추가로 생긴 궁금점

- File, ClassLoader 비교
- 데메테르의 법칙

<br>

# 5. 코드 리팩토링에서 시도해보고 싶은 점

- 싱글톤 패턴
- 커스텀 에러
- 라우팅 구조 개선
