# 1. 리뷰

## 오늘 한 작업

### 웹 서버 5단계 미션

- 로그인 Form 수정 → GET 요청 발생시키도록
- 사용자가 입력한 ID, PW에 따라 성공/실패 여부 확인
- 로그인 성공 시, 세션 ID 생성해서 쿠키로 클라이언트에게 전달
- HttpRequest에서 쿠키 정보를 파싱하여 저장
- 로그아웃 요청을 받으면, 쿠키에서 세션 아이디 확인하여 세션 삭제

### 코드 리뷰

- 경준님께서 달아주신 리뷰에 답변드리기
- 리뷰에서 지적 받은 내용들 중에서 코드 수정해 볼 사항 확인하기

<br>

## 작업 과정에서 배운 것

### 1. 코드 리뷰를 받아보고 느낀 점

경준님께서 남겨주신 리뷰를 읽어보면서 많은 것을 느꼈다.

내가 작성한 코드임에도 불구하고, 직접 봤을 때 눈치채지 못한 문제점이나 일관성 없는 부분들이 있었다. 다른 시각에서 봤을 때 눈에 들어오는 부분이 확실히 있다는 것을 느꼈다.

코드 작성 의도에 대한 질문을 받으며 “왜 이렇게 작성했는지” 논리적으로 설명하는 연습을 할 수 있었고, 그 과정에서 스스로의 생각을 되돌아보게 되었다.

단순한 문제 지적뿐만이 아니라, 잘한 부분에 대한 긍정적인 피드백도 함께 받아서, “이 부분은 잘하고 있구나” 라는 자신감도 얻을 수 있었다.

<br>

### 2. 그룹 세션 시간에, 단순한 상황 공유를 넘어 깊은 탐구까지 해보자

오늘 그룹 세션에서는 각자의 진행상황을 공유하는 것을 넘어, 조금 더 심도있는 이야기를 나눴다. 

상태를 가지지 않고 로직 수행만 하는 클래스를 어떻게 사용할지에 대한 주제였다. 유틸리티 클래스처럼 객체를 생성하지 않고 사용할지, 객체를 생성한다면 static으로 선언할 것인지 말 것인지 등, 다양한 방식들이 거론되었다. 각자 알고 있는 선에서 여러 가지 의견을 내봤지만 뚜렷한 결론이 나오지는 않았다.

그래서 관련된 자료를 같이 찾고 공유하면서, 조금 더 깊게 알아보는 시간을 가졌다. 여러 방식들의 차이점과 적합한 상황을 알 수 있었고, 그 과정에서 새로운 방식이 떠오르기도 했다.

앞으로도 단순히 작업 내용을 공유하는 데 그치지 않고, 한 가지 주제에 대해 깊게 탐구하고 토론해보는 시간을 정기적으로 가져보고 싶다.

<br>

## 어려웠던 점

### 1. 비슷한 개념에 대해 정확한 구분 없이 사용하고 있었다

객체가 하나만 존재한다는 점에서, static과 싱글톤 패턴을 거의 비슷한 개념이라고 생각하고 있었는데, 의존성 주입의 유연성이나 테스트성에서 큰 차이가 있었다.

마찬가지로, enum과 상수 클래스도 비슷한 역할을 한다고만 생각했는데, 타입 안정성이나 확장성 측면에서 enum이 훨씬 더 명확한 장점을 가지고 있었다.

당장은 비슷하게 보이고, 동작상 큰 차이가 없을 수도 있지만, 이런 개념을 정확히 구분하지 않고 사용하면 장기적으로는 치명적인 문제가 될 수 있다는 것을 느꼈다. 겉보기에는 유사한 개념이라도, 그 의도와 쓰임새를 정확히 구분해서 사용하는 습관을 가져야겠다.

<br>

### 2. 코드를 명시적으로 작성하는 법에 대한 고민

앞선 내용에서 이어진 고민이다.

지금의 내 코드에서, static/싱글톤 패턴, enum/상수 클래스 둘 중 어느 것을 사용하더라도 동작이 크게 바뀌지는 않는다. 하지만, 

- 하나의 객체만 사용하려고 의도해서 static으로 생성했던 클래스를 다른 곳에서 사용한다면?
- 당연히 HTTP 메서드를 입력할 것이라고 생각한 파라미터에 아무 문자열이나 넣게 된다면?

컴파일 시점에는 문제가 없기 때문에 그대로 오류가 발생하게 된다.

혼자 개발하는 소규모 프로젝트에서는, 어떤 의도로 작성했는지 내가 전부 기억하고 있기 때문에 다소 모호하거나 암묵적인 규칙이 있어도 크게 문제되지 않을 수도 있다.

하지만 프로젝트 규모가 커지고 여러 사람들과 협업하게 되면, 그런 논리와 의도를 기억하지 못하거나, 제대로 전달하지 못할 확률이 높다.

그렇기 때문에 코드를 명시적으로 작성해서, 혹여나 그런 숨은 의도를 몰라서 발생할 수 있는 문제들을 사전에 차단하는 것이 중요하다는 것을 느꼈다. 기능상으로는 전혀 문제가 없다는 점에서 오히려 쉽게 간과하게 되는 것 같다. 누가 보더라도 의도를 파악할 수 있고, 실수를 방지할 수 있는 구조를 항상 염두에 두고 코드를 작성해야겠다.

<br>

# 2. 회고

## Keep

### **1. 지식보다는 내가 고민했던 내용이 드러나게**

어제 작성했던 회고를 Dangle님께서 좋게 평가해주셨다. 고민을 가지고 정성을 들인 부분이 좋은 쪽으로 개선이 된 것 같아 뿌듯했다.

사실 정보 자체는 검색을 하거나, AI에게 물어보면 금방 얻을 수 있는 것들이 대부분이다. 하지만 내가 그때 어떤 문제를 겪었고, 어떤 생각을 했고, 어떻게 해결했는지는 어디에서도 얻을 수 없고, 심지어 시간이 지나면 사라져버리기도 한다.

이번 기회에 열심히 정리해둔 내용이 미래의 나에게도 도움이 되는 자산으로 남기를 바란다.

<br>

### 2. 알고 있는 내용을 설명해보기

그룹 세션 시간에, 먼저 조사했던 내용이나 알고 있던 정보들을 먼저 공유해보았다.

사실 예전에는 괜한 참견인가 싶기도 하고, 혹시라도 잘못된 정보를 전달하지는 않을까 걱정되어 잘 그러지 않았다. 이번에는 “그런 개념을 봤었는데 같이 한 번 자세히 알아보자” 라는 식으로, 나도 다시 공부해보자는 마음으로 공유를 해봤다. 

제대로 알고 있었던 내용이라면 그룹 멤버들에게 도움이 되었으니 좋은 일이다. 반대로 잘못 알고 있었던 내용이라도, 그것을 실전이 아닌 상황에서 바로잡을 수 있다는 건 오히려 감사한 일이다.

앞으로도 “완벽하게 알아야 공유할 수 있다”는 부담을 내려놓고, 같이 탐구해본다는 마음으로 더 많이 소통해보고 싶다.

<br>

## Problem

### **1. 수면 시간이 들쭉날쭉하다**

- 해야 할 일이 많기도 하고, 작업 흐름을 탈 때는 몰입하다 보니 늦은 시간까지 계속하게 되는 경향이 있다.
- 일어나야 하는 시간은 정해져 있기 때문에, 결과적으로 수면 시간이 부족해지는 경우가 종종 생긴다.
- 이런 생활이 누적되면 컨디션에도 영향을 주고, 작업 효율도 떨어질 수 있어 걱정된다.

<br>

### **2. 할 일이 많아지면서 시간 관리의 필요성이 생겼다**

- 미션의 난이도도 높아지고, 회고 작성, 코드 리뷰, 종합 프로젝트 리서치 등 해야할 일이 점점 많아지고 있다.
- 시간 안에 작업들을 마무리하기 위해서는 시간을 더 효율적으로 사용해야겠다는 생각이 들었다.

<br>

## Try

### **1. 적정량의 수면시간은 확보해두자**

- 피곤한 상태로 오랫동안 붙잡고 있는 것보다, 맑은 정신으로 집중해서 빠르게 해치우는 것이 훨씬 효율적이다.
- 일정이 빡빡하더라도 최소한의 수면 시간은 지킬 수 있도록 해보자.

<br>

### 2. 시간을 효율적으로 사용하자

- 어떤 작업을 어떤 상황에서 하는 게 가장 효과적인지 고민해보자. 이를테면,
    - 그룹원들과 있을 때는 토론이나 의사소통이 필요한 작업,
    - 혼자 있을 때는 집중이 필요한 작업,
    - 이동 중에는 간단한 자료 검색이나 아이디어 정리
- 이렇게 상황에 맞는 작업을 하면서, 시간을 효율적으로 사용해보자.

<br>

# 3. 학습내용

## ConcurrentMap

- 멀티스레드 환경에서도 안전하게 사용할 수 있는 Map 인터페이스
- 기본 Map과 비슷하지만, 동시성(Concurrency)에 특화됨

### ConcurrentHashMap

- 가장 많이 쓰이는 `ConcurrentMap` 구현체
- 내부적으로 락을 걸되, 전체 Map이 아닌 부분적으로만 락을 걸기 때문에 성능이 좋음
- 멀티스레드 환경에서 `HashMap` 대신 사용됨

### 사용하는 이유

- HashMap은 Thread-Safe하지 않음
    - 여러 스레드가 동시에 `put()` 또는 `get()`을 하면 내부 구조가 깨지거나, `ConcurrentModificationException` 발생 가능
- ConcurrentHashMap은 여러 스레드가 동시에 `put`, `get` 해도 충돌 없이 동작

### 주요 메서드

- `putIfAbsent(K key, V value)` : 이미 값이 없을 때만 저장함
- `remove(Object key, Object value)` :	key에 해당하는 value가 일치할 때만 제거
- `replace(K key, V oldValue, V newValue)` : 기존 값이 일치하면 바꿈
- `computeIfAbsent(key, k -> ...)` : key가 없을 경우에만 계산 후 저장

### 주의할 점

- `ConcurrentMap` 을 사용한다고 해서 모든 연산이 원자적이 되진 않음
    - ex) `if (!map.containsKey(k)) map.put(k, v);` → race condition 발생 가능
    - 대신 `putIfAbsent()` 같은 메서드를 써야 함

<br>

## UUID (Universally Unique Identifier)

고유한 ID를 만들기 위한 표준 형식의 식별자

- 128비트 숫자 (16바이트)
- 거의 중복되지 않을 확률이 매우 높음
- 다양한 시스템 간의 고유 식별자 생성에 많이 사용됨
- 형식: `8-4-4-4-12` (하이픈 포함 36자)
- `UUID.randomUUID()`로 랜덤 ID 생성 가능
    - `SecureRandom` 기반의 무작위 값으로 생성됨

### 장점

- 충돌 확률이 거의 없어, 안전하게 사용 가능
- 중앙 서버 없이도 독립적으로 생성 가능
- 표준화가 되어있어, 다양한 언어/플랫폼에서 동일한 포맷 사용

### 단점

- 36자의 문자열로, 저장 공간/성능에 민감한 경우 부담될 수 있음
- 순서가 없어서, 시간순 정렬이 필요하면 따로 Timestamp를 붙여야 함

<br>

## 가비지 컬렉션(Garbage Collection)이 필요한 이유

### 가비지

- 더 이상 사용되지 않는 객체(인스턴스)
- ex) 지역 변수로 만들었지만 함수 끝나고 참조가 끊긴 객체

### 가비지 컬렉션(Garbage Collection)

- 자바는 개발자가 직접 메모리 해제를 하지 않음
- JVM이 쓸모없는 객체를 찾아서 자동으로 메모리에서 제거

### 가비지 컬렉션이 필요한 이유

1. **메모리 누수 방지**

- 메모리를 해제하지 않으면, 더 이상 쓰이지 않는 객체가 계속 힙 메모리에 남아 있음
    - 이런 객체들이 많아지면 메모리 누수(memory leak) 발생
    - OutOfMemoryError 발생 가능

2. **개발자의 실수 줄이기**

- C나 C++ 같은 언어에서는 `malloc/free`, `new/delete`로 직접 메모리 관리를 해야 함
    - 언제 객체를 해제해야 할지 판단하기가 어렵고, 실수도 많음.
- 자바는 자동으로 메모리를 회수해주기 때문에 개발자가 로직에만 집중할 수 있음

3. **메모리 자원의 효율적인 사용**

- 사용되지 않는 객체를 제거함으로써 힙 메모리를 재사용할 수 있게 해줌.
    - 동일한 메모리 공간을 여러 번 재활용할 수 있어 효율적

4. **프로그램의 안정성과 유지보수 향상**

- 수동 메모리 관리는 실수가 많고 디버깅도 어려움
    - 자바는 자동 GC 덕분에 안정적인 메모리 관리가 가능
    - 유지보수가 쉬워짐

<br>

### 자바 가비지 컬렉션의 작동 원리

- JVM은 힙 영역을 크게 두 가지로 나누어 관리
    - 대부분의 객체는 금방 사라진다는 통계적 사실을 바탕으로 설계된 구조
    - 일시적인 객체는 빠르게 정리하고, 오래 사는 객체는 효율적으로 관리하는 전략

**1. Young Generation (영 제너레이션)**

- 새로 생성된 객체들이 저장되는 공간
- 대부분의 객체는 여기에서 생성되고, 빠르게 사라짐
    - Eden(에덴): 대부분의 객체가 여기에 생성됨.
    - Survivor S0 / S1: 에덴에서 살아남은 객체들이 여기에 복사됨. (두 개를 번갈아 사용)

**2. Old Generation (올드 제너레이션)**

- Young에서 오래 살아남은 객체들이 이쪽으로 옮겨짐
    - ex) 싱글톤 객체, 캐시, 세션 등 장기 사용 객체
- GC가 자주 일어나지 않지만, 발생하면 시간이 오래 걸려서 Stop-the-World 현상이 큼.

<br>

### 가비지 컬렉션 종류

**Minor GC**

- Young Generation에서 발생
- Eden 영역이 가득 차면 발생
- 살아남은 객체들은 Survivor 영역으로 이동하거나 Old로 승격됨
- 빠르고 자주 발생

**Major(Full) GC**

- Old Generation에서 발생
- 메모리가 부족하거나 시스템이 강제로 요청할 때 수행
- 속도가 느리고 CPU 사용량이 높아 전체 성능에 영향 줄 수 있음

<br>

## JIT(Just-In-Time) 컴파일러

- 자바 프로그램을 실행 중에 바이트코드를 네이티브 머신 코드로 변환하는 컴파일러

### 자바의 기본 실행 흐름

1. 컴파일 단계: 컴파일러(javac)가 자바 소스코드를 바이트코드(`.class` 파일)로 변환
2. 실행 단계: JVM이 바이트코드를 한 줄씩 해석해서 실행 (인터프리터 방식)

초기 JVM은 바이트코드를 인터프리터 방식으로 한 줄씩 읽어 실행했기 때문에 느렸음

### JIT 컴파일러의 역할

- JVM 내부에 들어 있는 컴파일러로,
- 실행 중에 자주 실행되는 코드(HotSpot)를 찾아 기계어로 미리 변환

### 동작 흐름

1. 자바 프로그램 실행 시작 → 인터프리터가 실행
2. JVM이 특정 메서드나 루프가 자주 호출되는 걸 감지 → HotSpot으로 판단
3. JIT 컴파일러가 해당 바이트코드를 기계어로 컴파일
4. 이후부터는 기계어 코드로 빠르게 실행됨
5. 최적화된 코드로 대체되며 실행 성능 향상

### JIT의 핵심 최적화 기능

| 기능 | 설명 |
| --- | --- |
| **인라인 확장 (Inlining)** | 자주 호출되는 메서드를 호출하지 않고, 내부 코드로 바꿔버림 |
| **루프 최적화 (Loop unrolling)** | 루프를 펼쳐서 실행 시간 단축 |
| **가상 호출 제거** | 객체 타입이 고정돼 있으면 가상 메서드 호출을 일반 호출로 최적화 |
| **불필요한 객체 제거** | Escape analysis 기반으로 힙이 아니라 스택에 객체를 생성함 |
| **디버깅 정보 제거** | 디버그가 필요 없을 때는 더 최적화된 코드로 바꿈 |

<br>

## 추가로 생긴 궁금점

- 싱글톤 클래스를 필드로 갖는 것과 static으로 선언해서 필드로 갖는 것의 차이에 대해 조금 더 확실히 알아보기
