# 1. 리뷰

## 오늘 한 작업

### 코드 리뷰

- GitHub에서 코드 리뷰 작성하는 방법에 대해 조사
- 그룹 멤버들의 PR에 코드 리뷰 작성

### 종합프로젝트

- 개발 파트 인원들끼리 기능/기술 구체화에 대한 회의
    - 사용 가능한 기술들에 대한 리서치

### 웹 서버 4단계 미션

- PR merge하는 과정에서 발생한 Conflict 해결

<br>

## 작업 과정에서 배운 것

### 1. 코드 리뷰를 통해 얻을 수 있는 것

코드 리뷰를 작성해보는 것은 처음이었다. 작성하는 방법이나 형식에 대해 아무 것도 몰랐기 때문에, 이번 기회를 통해 공부하면서 작성해봤다. 다른 사람들이 먼저 작성해주신 리뷰들을 보니, 어떤 식으로 해야할지 감이 잡혔다.

다른 사람이 작성한 코드를 읽는 경험 자체가 큰 공부였다. 이 코드가 무엇을 하고자 하는지, 어떤 흐름으로 동작을 수행하는지 이해하기 위해 많이 생각해볼 수 있었다.

또한 리뷰를 작성하면서, 나와 이 사람의 생각이나 관점의 차이를 발견할 수 있었다. 두 방식을 비교해보면서, 내 생각에 대해서도 훨씬 구체적이고 논리적으로 정리하게 되었다. 

마지막으로, 상대방의 코드에서 문제를 발견했을 때, 감정이 상하지 않도록 전달하는 방법에 대해서도 고민해볼 수 있었다. 지금은 같이 공부를 하는 관계에서의 코드 리뷰이기 때문에 가벼운 마음으로 이야기할 수 있다. 하지만 업무를 하면서 생기는 의견 차이는 감정적인 갈등의 원인이 될 수도 있다. 꼭 해야할 말을 최대한 부드럽게 전달하는 연습을 할 수 있었다.

<br>

### 2. Git 관리에 조금 더 신중을 기하자

1주차 PR을 merge하는 과정에서 Conflict가 발생했다.

코드에는 전혀 이상이 없었고, README.md에서 문제가 있었다. 기억을 되짚어보니, 해당 브랜치를 만들고 나서 GitHub으로 이전 브랜치의 README.md를 확인하다가, 마음에 들지 않는 부분이 있어 웹페이지에서 직접 수정했던 기억이 났다. 새로운 브랜치에는 해당 변경을 반영하지 않았기 때문에 충돌이 발생했던 것이다.

너무 기초적인 실수를 해버려서 조금 황당했다. Git를 관리할 때는 조금 더 신중함을 가지고, 되도록이면 관리 방식을 통일해서 사용해야겠다.

<br>

### 3. 중요한 문제는 도움을 받는 편이 낫다

PR merge 문제를 해결하다가, 실수로 문제를 더 악화시키지는 않을까 하는 걱정이 있었다. 

다행히 같은 그룹이었던 경준님께서 바로 전에 비슷한 문제를 겪었다고 하여 해결 방법을 여쭤보았다. 설명을 듣고나서 안전한 방법으로 병합을 수행했고, 문제를 무사히 해결할 수 있었다.

혼자서 알아보고, 고민하는 과정에도 분명히 의미가 있다. 하지만 실수를 피해야하는 상황이나, 단순히 정보의 부족이 문제의 원인인 경우에는, 경험이 많고 잘 아는 사람의 조언을 받는 것이 훨씬 현명한 방식인 것 같다.

<br>

## 어려웠던 점

### 1. 종합프로젝트 기능 구체화하기

기획/디자인 팀원분들과 논의를 거쳐, 솔루션의 방향성과 대략적인 주요 기능들은 도출되었다. 이후 개발 팀원들끼리 따로 회의를 진행하며 기능을 조금 더 구체화하고, 필요한 경우 추가 기능도 고려해보기로 했다.

기능을 구체화하는 과정이 어려웠다. 기술적으로 도전해보고 싶은 영역인지, 구현 가능성이 있는지, 프로젝트의 주제에 정말 필요한 기능인지 등 많은 요소들을 고려해야 했다. 모든 조건에서 만족스러운 기능을 떠올리는 게 쉽지 않았다.

팀원들과 이야기를 나누며, 기능을 확정짓기 위해선 기술적인 조사와 이해가 더 필요하겠다는 것을 실감했다. 레퍼런스 자료를 찾아보며 실제로 사용할 수 있는 도구가 있는지, 있다면 어떤 방식으로 활용할 수 있을지 파악하는 일이 먼저라는 생각이 들었다. 조금 더 시간을 들여 기술적 기반을 다진 뒤에 다시 구체적인 논의를 이어가기로 했다.

<br>

# 2. 회고

## Keep

### 1. **궁금했던 점을 정리하고 해결하려는 습관을 가지기**

- 회고를 작성할 때, 그날 해결하지 못한 궁금한 점들을 따로 정리해두고 있다.
- 시간이 부족해 찾아보지 못했을 경우에도, 다음 날이나 시간이 날 때 꼭 조사해보고 있다.
- 궁금증을 그냥 넘기지 않고 기록하고 해결하려는 습관을 앞으로도 계속 유지하고 싶다.

### 2. **능동적으로 작업 상황을 공유해보기**

- 지금까지는 누가 물어보거나, 스스로 막막함을 느낄 때에만 상황을 공유하는 경우가 많았다.
- 최근에는 스크럼 시간 등을 활용해, 그룹 멤버들과 지금 하고 있는 일들을 능동적으로 공유하려고 노력하고 있다.
- 혼자서만 고민할 때는 문제를 인식하지 못하거나, 더 나은 방법이 있어도 떠올리지 못할 수도 있다. 하지만 팀원들과의 소통을 통해, 내가 미처 인식하지 못한 문제도 피드백 받을 수 있었다.

<br>

## Problem

### 1. **회고나 문서에서 내 '느낀 점'이 덜 부각되는 것 같다**

- 회고나 README를 작성할 때, 관련된 공부 내용과 정보를 함께 정리하는 경우가 많다.
- 그러다 보니 **그때 내가 어떤 고민을 했고, 어떤 생각을 했는지**가 상대적으로 묻히는 경향이 있었다.
- 단순한 정보 정리도 중요하지만, **나만의 경험과 고민이 더 잘 드러나야** 진짜 의미 있는 회고가 될 수 있다는 걸 느꼈다.

### 2. **Git 관련 문제 상황에 능숙하게 대처하지 못했다.**

- 일상적으로 다루는 commit, push 등의 동작들은 익숙하게 사용하고 있다.
- 하지만 오늘처럼 예상치 못한 충돌이나 문제 상황이 발생했을 때는, 대처 경험이 부족해서 당황하게 되는 것 같다.

<br>

## Try

### **1. 지식보다는 내가 고민했던 내용이 드러나게**

- 그날 겪었던 어려움이나, 고민하고 해결했던 내용들이 더욱 잘 드러나도록 글을 구성해보자.
- 관련하여 공부한 내용들은 하단에 따로 정리하여, 필요할 때 찾아볼 수 있게 하자.

### 2. **Git 문제 대응 능력 키우기**

- 일상적인 Git 사용뿐만 아니라, 충돌 해결이나 브랜치 관리 같은 문제 상황 대응법도 평소에 연습해보자.
- GUI 도구에만 의존하지 않고, CLI 환경에서 Git을 직접 다루는 것에 조금 더 익숙해지자.

<br>

# 3. 학습내용

## JVM vs. JRE vs. JDK

### JVM (Java Virtual Machine)

- 자바 바이트코드를 실행하는 가상 머신
- 메모리 관리, gc, 스레드 관리
- 플랫폼 독립성 보장
- 메모리 관리, 성능 확인을 위해서는 JVM 레벨까지 들어가야 함
- Write Once Run Everywhere

### JRE (Java Runtime Environment)

- 자바 프로그램을 실행하기 위한 환경
- JVM + 실행에 필요한 라이브러리(기타 리소스)
- 자바로 작성된 프로그램을 실행할 수 있게 해줌

### JDK (Java Development Kit)

- 자바 프로그램을 개발하기 위한 도구
- JRE + 개발 도구들(컴파일러(javac), 디버거 등)
- 자바 프로그램을 작성하고, 컴파일하고, 테스트할 수 있는 개발 환경 제공

<br>

## JVM의 구조

### 1. Class Loader

- .class 파일(바이트코드)을 JVM으로 불러오는 역할
- Runtime Data Area에 저장시킴

<br>

### 2. Runtime Data Area

- JVM이 실행 시에 사용하는 메모리 공간
- **Heap**
    - new로 생성한 객체가 저장되는 공간
    - GC(Garbage Collector)의 대상이 되는 영역
    - 모든 스레드가 공유함
- **Stack**
    - 각 스레드마다 별도로 존재
    - 메서드 호출 시 스택 프레임 생성
    - 지역변수, 매개변수, 반환주소 등 저장
- **Method Area**
    - 클래스 로더가 읽어들인 클래스의 메타정보 저장
    - 클래스 이름, 메서드 이름, static 변수, 상수 풀 등
- **PC Register**
    - 현재 실행 중인 명령어의 위치 저장
    - JVM은 스레드마다 하나의 PC 레지스터를 가짐
- **Native Method Stack**
    - C, C++ 등 네이티브 메서드를 호출할 때 사용하는 스택

<br>

### **3. Execution Engine**

- 로드된 바이트코드를 실제로 실행하는 부분
- 실행 중 필요한 정보를 Runtime Data Area에서 가져옴
- **Interpreter**
    - 바이트코드를 한 줄씩 해석하며 실행
        - 시작은 빠르지만 속도가 느림
- **JIT(Just-In-Time) Compiler**
    - 자주 실행되는 코드(핫스팟)를 기계어로 컴파일해서 캐시
        - Interpreter를 거치지 않고 바로 실행 가능
        - 실행 속도 대폭 향상

<br>

### **4. Native Method Interface**

- 자바 코드에서 C, C++ 등의 네이티브 메서드 라이브러리를 사용할 수 있게 해주는 인터페이스

<br>

## Stack Area

- JVM Runtime Data Areas 중 하나
- 각 스레드 별로 독립적인 JVM 스택을 가짐

### Thread n

- JVM에 의해 생성된 하나의 스레드
- Java 애플리케이션은 하나 이상의 스레드를 가질 수 있음 (예: `main`, `GC`, 사용자 스레드)
- 각 스레드는 자신만의 Stack 영역을 갖고 있음 → 스레드 안전성 확보

<br>

### Stack Frame

- 메서드가 호출될 때마다 하나의 Stack Frame이 생성됨
- 메서드가 리턴되면 그에 해당하는 Stack Frame은 Stack에서 제거됨 (LIFO 구조)
- 하나의 스레드 안에는 여러 개의 Stack Frame이 쌓여 있음 (메서드 호출 체인)

<br>

### Stack Frame 내부 구성

- JVM은 하나의 메서드를 실행할 때 3가지 정보를 Stack Frame에 담아 관리

**1. Local Variable Array**

- 지역 변수 저장소
- 메서드의 파라미터와 지역 변수 저장
- 정수형, 참조형(String 등), 배열 등 모두 여기에 저장됨

<br>

**2. Operand Stack**

- 명령어 실행 중 임시 값을 저장하는 스택
- 바이트코드 명령어는 Stack 기반 → 연산 대상을 Operand Stack에 push/pop
- JVM은 Operand Stack을 사용해 연산을 수행함

<br>

**3. Frame Data**

- 메서드 실행 중 필요한 제어 흐름 관리용 정보(컨텍스트) 보관
    - 리턴 주소 (caller로 복귀 시점)
    - 예외 핸들러 정보
    - 디버깅/스택 추적용 정보

<br>

## Stream 문법을 사용할 때의 성능 상 이점?

### **장점**

- 병렬 처리가 빠름
    - CPU 코어를 여러 개 사용할 수 있기 때문에 대량 데이터 처리에 효과적
    - 작은 데이터셋에는 오히려 느릴 수 있음 (스레드 생성/관리 비용 때문)
- Lazy Evaluation(지연 연산)을 지원함
    - `filter`, `map` 같은 중간 연산은 실행되지 않음
    - `findFirst`, `collect` 같은 최종 연산이 호출될 때 비로소 실행됨

### **단점**

- 함수형 인터페이스 호출 비용
    - 각 연산이 `Function`, `Consumer` 같은 람다 객체로 호출됨
        - 일반 메서드 호출보다 느림
- Boxing/Unboxing 오버헤드
    - 기본형을 다룰 때는 객체로 포장(Boxing) 되고 다시 꺼내야 함
        - 성능 손해

<br>

## TreeMap

- `NavigableMap` 인터페이스를 구현한 Map
- 내부적으로 Red-Black Tree(균형 이진 탐색 트리) 기반으로 구현됨
- Key를 정렬된 상태로 저장함 (`Comparable` 또는 `Comparator` 필요)

### 특징

- Key가 자동으로 정렬됨 (오름차순 기본)
    - 범위 기반 탐색 가능
- 삽입/삭제/탐색 모두 O(log n)
- 정렬된 순서대로 순회 가능 (`firstKey`, `higherKey` 등)

<br>

## Trie (Prefix Tree)

- 문자열 검색에 최적화된 트리 구조
- 각 노드가 문자의 한 글자를 저장
- 주로 문자열의 접두사 검색에 사용

### 특징

- 문자열 검색/자동완성/사전 구조에 적합
- 문자열 길이 = L일 때 → 탐색 시간 O(L)
- 많은 문자열이 같은 접두사를 가질 경우, 공간 절약
- 노드 순서를 정렬하면, 사전 순 정렬도 가능

<br>

# 4. 추가로 생긴 궁금점

- 가비지 컬렉션이 필요한 이유 (Young, Old Generation 학습)
- JIT 컴파일러의 동작 원리 학습
