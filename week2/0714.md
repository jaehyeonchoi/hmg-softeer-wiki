# 7/14(월)

# 1. 리뷰

## 오늘 한 작업

### **웹 서버 4단계 미션**

- POST 방식으로 회원가입 요청이 전송되도록 수정
    - 회원가입 html 파일의 form 태그 내 method를 get에서 post로 수정
- HTTP Request의 Body에서 User 정보 추출
    - Content-Length를 확인하여, Header 아래 Body 부분을 읽기
    - Body에 들어있는 Form Data를 파싱하여 User 정보 추출
    - User 정보를 통해 객체를 생성하고, Database에 저장

<br>

## 작업 과정에서 배운 것

### 1. 문제가 생겼을 때는 어디까지 성공했는지 찾아보자

Request Body를 읽는 과정에서 문제가 발생했을 때, 그 원인을 찾기가 쉽지 않았다. 
어디서 문제가 생겼는지를 찾기보다는, 반대로 어디까지 문제가 없는지를 찾아봤다. 의심하지 않아도 되는 영역을 확실히 정리하고 나니, 문제가 발생한 지점을 확인하기 수월했다.

### 2. 로그를 적절하게 활용하자

1번 항목과 연계되는 내용이다. 프로그램의 동작에서 중요한 부분들에 로그를 남겨두었던 것이 디버깅에 큰 도움이 되었다. 로그를 잘 출력하고, 출력된 로그를 잘 해석하는 것이 중요하다는 것을 배울 수 있었다.

### 3. 당장 필요한 구현과 미래를 위한 구현 사이의 균형

이번 미션은 form-data만 처리하면 되었기 때문에 Request Body를 String으로 읽어도 무방했지만,추후 확장 가능성을 고려해서 byte 기반 처리도 고민해보았다.
결국에는 현 상황에 맞는 간단한 구현으로 돌아오긴 했지만, 구현 과정에서 향후의 확장 가능성과 그 방향을 고려하는 과정 자체가 중요하다는 것을 다시 한 번 깨달았다.

<br>

## 어려웠던 점

### **1. HTTP Request의 Body를 어떻게 저장할까? - String vs. byte 배열**

**String으로 읽는 게 편한 경우**

- application/x-www-form-urlencoded (폼 데이터)
- application/json, text/plain, text/html 등

**String만 사용하는 게 문제가 되는 경우** 

- 이미지
- 파일
- 이진 데이터 (예: multipart/form-data, application/octet-stream)
- 문자열로 읽으면 깨지거나 잘리거나 이상하게 디코딩될 수 있음
    - byte 단위처리가 필요

이번 미션은 POST 요청의 Form Data를 읽는 것이 목적이기 때문에 String으로 읽어도 무방하지만, byte로 읽는 방식에 도전해보기로 했다. 

<br>

### 2. Body를 InputStream으로 읽는 과정에서의 문제

InputStream을 통해, Body를 byte 배열로 읽었다.

제대로 읽었는지 확인하기 위해 문자열로 변환해보니 빈 문자열이 들어와 있었다. 알아보니 Header를 읽을 때 `BufferedReader`를 사용했는데, **`BufferedReader`가 이미 `InputStream`의 내용을 Body 부분까지 읽어버린 것**이 문제의 원인이었다.

**Header를 읽는 부분 역시 `InputStream`를 통해 직접 byte 형태로 읽음**으로써 문제를 해결할 수 있었다. 하지만 Header와 Body 모두 String 형태로 사용되는 이번 미션에서는 다소 불필요한 구현이라고 느껴져, 실제 구현은 문자열을 입력 받는 방식으로 결정했다.

<br>

### 3. Body를 BufferedReader로 읽는 과정에서의 문제

Body를 문자열 형태로 입력받는 방식으로 다시 구현해보고자 했다.

Header와 마찬가지로 `BufferedReader`의 `readLine()` 메서드로 읽으려고 했으나 실패했다. Body가 읽히지 않은 상태로 계속 대기하다가, 다음 요청이 왔을 때 읽히는 현상이 있었다.

원인을 알기 위해 조사해본 결과, **Body는 개행으로 끝나지 않을 수도 있다**는 것을 알게 되었다. 개행이 없었기 때문에 `readLine()` 메서드가 입력스트림이 닫힐 때까지 계속 대기 상태로 있었던 것이다.

BufferedReader의 **`read()` 메서드**를 통해 문제를 해결할 수 있었다. 원하는 길이만큼의 문자열을 char 배열 형태로 읽어오는 메서드이다. Content-Length만큼을 char 배열로 읽어온 후 String으로 변환하도록 했다.

<br>

## 2. 회고

### Keep

**1. 적극적인 질문과 문제 공유**

- 정해진 시간 이외에도 그룹원들과 서로의 코드에 대해 이야기하는 시간을 가졌다.
- 상대방의 코드에서 모르는 개념이나 이해가 안되는 구현 방식이 있으면, 주저하지 않고 세세하게 물어봤다. 그룹원들도 친절하게 설명해줘서 많은 공부가 되었다.
- 구현과 관련된 고민도 혼자서 끙끙 앓기보다는 소통 시간에 공유해봤다. 서로의 고민을 들으면서 더 좋은 해결방법을 알게 되기도 하고, 전혀 생각치도 못했던 부분에 대해 고민해볼 수 있어 좋았다.

**2. 작업 도중에 틈틈이 기록하기**

- 작업을 하면서 조사한 개념이나, 겪었던 이슈, 해결 방법 등을 수시로 기록해두었다.
- 나중에 디버깅을 하거나, 회고를 작성할 때 큰 도움이 되었다.

**3. 새로운 방식을 적용해보기**

- Record 클래스나, InputStream으로 byte를 읽기와 같이, 한 번도 해 본 적 없는 새로운 방식을 만나면, 가볍게라도 적용해보려고 노력했다.
- 좋은 방법을 알게 되어도 머릿속으로만 아는 것보다, 실제로 써보면서 이점이나 편의성을 직접 체감하는 것이 훨씬 더 공부가 되는 것 같다.

<br>

### Problem

**1. 깊이가 부족한 기초 지식**

- 기초적인 지식이라고 생각했는데, 자세히는 모르고 있다든가, 다른 사람에게 설명하기 어려운 것들이 많다는 것을 실감했다.
- 잘 사용하지 않는 고급 지식을 많이 아는 것보다, 늘 사용하는 기초 지식을 탄탄하게 다질 필요가 있다고 느꼈다.

**2. 비효율적인 디버깅**

- 디버깅 시에 문제의 원인을 정확히 찾는데 어려움을 겪거나, 너무 많은 시간을 소비하는 경향이 있다고 생각했다.

<br>

### Try

**1. 기초 지식에 대해 궁금증을 가져보자**

- 당연하게 여기고 사용했던 기초 지식에 대해서도 추가적인 의문점을 계속 떠올리고 찾아보자
- 코드를 작성할 때도 현재 사용하고 있는 개념에 대해, 한 번도 알아보는 시간을 가지자

**2. 디버깅을 위한 준비를 미리 해두자**

- 코드의 동작과 상태를 기록할 수 있는 로그를 적극적으로 활용하자
- 디버깅 툴을 쓰는 법을 연습해서 도움을 받을 수 있도록 하자

<br>

## 3. 학습내용

### String

**1. char와 String의 비교**

**char**

- 16비트(2바이트) 크기의 유니코드 문자를 저장
- 원시 타입

**String**

- 문자열의 길이에 따라 메모리 사용량이 가변적 (최소 수십 바이트)
- 참조 타입 (immutable)
- 주요 메모리 구성
    - 객체 자체 오버헤드
    - 내부 char 배열
    - 기타 필드

**예시)**

| 표현 | 의미 | 메모리 사용량 |
| --- | --- | --- |
| `char c = 'A';` | 문자 하나 | 2바이트 |
| `String s = "A";` | 문자 하나 포함된 문자열 | 약 40바이트 이상 (JVM 의존) |

<br>

**2. String의 불변성 (immutable)**

- 한 번 생성된 String 객체의 값은 바뀌지 않음
    - 항상 새로운 객체를 생성

**장점**

1. **안정성**: 값이 변경되지 않으므로 예측 가능한 동작이 보장됨
2. **Thread-Safe**: 동기화 없이 멀티스레드 환경에서도 안점
3. **성능** **향상**: 해시 캐싱, 리터럴 재사용 등으로 메모리/속도 효율 높음
4. **보안**: 중요 문자열이 외부에서 변경되지 않도록 보호

**단점**

1. **변경이** **불가능**: 문자열을 바꿀 때마다 새로운 객체를 생성해야 함
2. **성능** **저하** **가능성**: 문자열을 자주 조작하는 경우, 객체 생성이 많아져 힙 메모리 사용 증가

<br>

**3. 문자열 연결 방식**

1. **`String.concat()` 메서드**
- 내부적으로 새로운 문자열 객체 생성
    - 성능적으로 비효율적
    
2. **`+` 연산자**
- 컴파일러가 내부적으로 StringBuilder를 사용하여 변환
    - append(), toString() 사용
- 간단한 연결은 상관 없지만, 반복문 등으로 여러 번 연결할 때는 성능 저하 발생

3. **`StringBuilder`**
- 내부에서 가변 배열로 관리됨
- 메모리 효율이 좋고, 성능이 우수함

4. **`StringBuffer`**
- `StringBuilder`와 거의 동일하지만, synchronized 처리되어 Thread-safe

<br>

**4. StringBuilder와 StringBuffer의 차이**

**`StringBuilder`**

- 속도 빠름
- 쓰레드 동기화 지원 안함

**`StringBuffer`**

- StringBuilder에 비해 속도 느림
- 쓰레드 동기화 지원 → Thread-Safe

<br>

### 자료구조

**1. Generic**

데이터타입을 클래스 내부에서 지정하지 않고 외부에서 사용자에 의해 지정되도록 하는 것

- 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지 가능
- 타입 체크 및 변환할 필요가 없어 관리하기 용이함
- 비슷한 기능을 제공하고 데이터타입만 다를 경우 재사용성이 높아짐

<br>

**2. Array, List, Set, Map**

| 구조 | 순서 | 중복 | 접근 속도 | 특징 |
| --- | --- | --- | --- | --- |
| **Array** | 있음 (인덱스) | 허용 | 빠름 | 고정 크기, 빠른 접근 |
| **List** | 있음 (인덱스) | 허용 | 빠름 | 동적 크기, 순서 보장 |
| **Set** | 없음 또는 있음(Linked/Tree) | 불가 | 빠름 (Hash) | 유일한 값 저장 |
| **Map** | 키 기반 | 키: 불가 / 값: 가능 | 빠름 (Hash) | Key-Value 저장 |

<br>

**3. 대량 데이터를 검색할 때, Array, List, Set, Map의 속도 비교**

|  | 평균 검색 속도 | 최악 검색 속도 | 설명 |
| --- | --- | --- | --- |
| **Array** | O(n) | O(n) | 순차 검색. 정렬되어 있어도 이진 탐색을 쓰려면 직접 구현 필요 |
| **List (ArrayList)** | O(n) | O(n) | 내부적으로 배열 기반. `contains()`는 선형 검색 |
| **List (LinkedList)** | O(n) | O(n) | 노드 따라가며 탐색. 오히려 더 느림 |
| **Set (HashSet)** | **O(1)** | O(n) | 해시 기반. 충돌 많으면 성능 저하 가능 |
| **Set (TreeSet)** | O(log n) | O(log n) | 이진 탐색 트리 기반 (정렬됨) |
| **Map (HashMap)** | **O(1)** | O(n) | 키로 검색할 때 매우 빠름. 해시 충돌 주의 |
| **Map (TreeMap)** | O(log n) | O(log n) | 키 정렬 필요 시 사용. 이진 탐색 트리 기반 |

<br>

### Exception

**1. Checked Exception vs. Unchecked Exception**

**Checked Exception**

- 반드시 예외처리 필요 → try-catch, throws 등
- Exception 클래스 상속
- 프로그램 외부의 요인에 따라 발생할 수 있는 문제 → 파일, DB, 네트워크 등

**Unchecked Exception**

- 예외 처리 강제되지 않음
- RuntimeException 클래스나 그 하위 클래스 상속
- 런타임에 발생 가능, 처리 안해도 컴파일 가능
- 코드 자체의 문제 → 예외 처리보다는 코드 수정이 우선

<br>

**2. Error vs. Exception**

**Error**

- JVM 자체의 심각한 오류
- `OutOfMemoryError`, `StackOverflowError` 등
- 개발자가 처리하거나 복구 불가능 → catch하지 않는 것이 원칙

**Exception**

- 프로그램 실행 중 발생하는 문제
- `NullPointerException`, `IOException` 등
- 개발자가 처리 가능 → try-catch, throws로 예외 처리

<br>

**3. 사용자 정의 Exception을 사용하는 상황**

- 비즈니스 로직에서 명확한 의미 부여가 필요할 때
- 세밀한 예외 처리가 필요할 때 → 회원 가입 중 오류 발생/ 이미 사용중인 이메일
- 예외를 계층적으로 관리하고 싶을 때
- 특정 예외를 명시적으로 throws해서 선언적으로 표현하고 싶을 때

<br>

**4. Exception을 직접 catch 하기 vs. 상위 메서드로 throws 하기**

**직접 catch**

- 예외를 발생한 곳에서 직접 처리
- 코드가 단순하고, 응답이 빠름
- 외부에 영항 없음
- 처리 로직이 분산되기 쉬움

**상위 메서드로 throws**

- 예외처리를 상위 호출자에게 위임
- 코드의 책임이 명확해짐
- 예외를 하나의 계층에서 일괄 처리 가능
- 한 종류의 예외상황을 호출된 위치에 따라 다르게 처리 가능
- 예외 흐름을 추척하기 어려워짐

<br>

### 추가로 생긴 궁금점

- String Constant Pool의 내부적인 작동방식?
- StringBuilder, StringBuffer의 내부 구조?
- synchronized vs. lock?
- List 종류별 특성?
